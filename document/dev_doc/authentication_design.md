# 質問管理Webシステム 認証システム設計

## 1. 概要

本ドキュメントは、質問管理Webシステムの認証および認可に関する設計を定義します。ユーザーはメールアドレスとパスワードを用いて認証され、役割（ロール）に基づいてシステム機能へのアクセスが制御されます。

### 1.1. 認証不要パス

以下のパスは認証なしでアクセス可能です:

* `/login` - ログイン画面
* `/register` - ユーザー登録画面
* `/reset-password` - パスワードリセット画面
* `/api/auth/login` - ログインAPI
* `/api/auth/register` - ユーザー登録API
* `/api/auth/request-password-reset` - パスワードリセット要求API
* `/api/auth/reset-password` - パスワードリセット実行API

それ以外のすべてのパスは認証が必要です。

## 2. 認証フロー

### 2.1. ユーザー登録

1.  ユーザーは登録画面で氏名（任意）、メールアドレス、パスワードを入力します。
2.  フロントエンドは入力値を検証します（メール形式、パスワード強度など）。
3.  フロントエンドは `/api/auth/register` エンドポイントにPOSTリクエストを送信します。
4.  バックエンドはメールアドレスの重複を確認します。
5.  バックエンドはパスワードを安全なハッシュアルゴリズム（bcryptjs）でハッシュ化します。
6.  バックエンドは `User` テーブルに新しいユーザーレコードを作成します（デフォルトロールは `USER`）。
7.  バックエンドは成功レスポンス（ユーザー情報）を返します。

### 2.2. ログイン

1.  ユーザーはログイン画面でメールアドレスとパスワードを入力します。
2.  フロントエンドは `/api/auth/login` エンドポイントにPOSTリクエストを送信します。
3.  バックエンドは提供されたメールアドレスでユーザーを検索します。
4.  ユーザーが見つかった場合、バックエンドは提供されたパスワードとデータベースに保存されているパスワードハッシュを比較します。
5.  認証が成功した場合、バックエンドはユーザー情報（ID, email, name, role）を含むペイロードでJWT（JSON Web Token）を生成します。
6.  バックエンドはJWTおよびユーザー情報をレスポンスとして返します。
7.  フロントエンドはJWTをZustand storeに保存し、認証に使用します。
8.  以降の認証が必要なリクエストでは、フロントエンドはJWTを `Authorization: Bearer <token>` ヘッダーに含めて送信します。

### 2.3. ログアウト

1.  ユーザーがログアウト操作を行います。
2.  フロントエンドは `/api/auth/logout` エンドポイントにPOSTリクエストを送信します（任意）。
3.  フロントエンドは保存しているJWTをZustand storeから削除します。
4.  ユーザーはログイン画面にリダイレクトされます。

### 2.4. パスワードリセット

1.  **リクエスト:**
    *   ユーザーは「パスワードをお忘れですか？」リンクをクリックし、メールアドレスを入力します。
    *   フロントエンドは `/api/auth/request-password-reset` にPOSTリクエストを送信します。
    *   バックエンドは一時的なリセットトークン（有効期限付き、ランダムで推測困難な文字列）を生成し、データベースに保存（またはトークン自体に有効期限情報を含める）します。
    *   バックエンドはリセットトークンを含むURL（例: `https://your-app.com/reset-password?token=...`）を生成し、ユーザーのメールアドレス宛に送信します。
2.  **リセット実行:**
    *   ユーザーはメール内のリンクをクリックし、パスワードリセット画面にアクセスします。
    *   フロントエンドはURLからリセットトークンを取得します。
    *   ユーザーは新しいパスワードを入力します。
    *   フロントエンドは `/api/auth/reset-password` にPOSTリクエストを送信します（リセットトークンと新しいパスワードを含む）。
    *   バックエンドはリセットトークンを検証（存在確認、有効期限確認）します。
    *   トークンが有効な場合、バックエンドは新しいパスワードをハッシュ化し、該当ユーザーのパスワードハッシュを更新します。
    *   バックエンドは使用済み（または期限切れ）のリセットトークンを無効化します。
    *   バックエンドは成功レスポンスを返します。
    *   ユーザーはログイン画面にリダイレクトされます。

### 2.5. 認証エラー処理

1. **クライアントサイドリダイレクト:**
   * APIリクエスト時に認証エラー（401 Unauthorized）が発生した場合、クライアントサイドで自動的にログイン画面へリダイレクトします。
   * fetchData関数内で401ステータスコードを検出した場合、`window.location.href = '/login'`を実行してリダイレクトします。
   * これにより、トークン期限切れや無効なトークンでのアクセス時に、ユーザーは自動的にログイン画面へ誘導されます。

2. **ミドルウェアによる保護:**
   * クライアントサイドのルーティングについては、Next.jsのミドルウェア（app/middleware.ts）が保護対象パスへの未認証アクセスを検出し、ログイン画面へリダイレクトします。
   * API経路については、上記のクライアントサイドリダイレクトに加えて、APIミドルウェア（middleware.ts）が認証ヘッダーを検証し、認証が必要なエンドポイントで401レスポンスを返します。

3. **ユーザーエクスペリエンス:**
   * 認証エラーでリダイレクトされた場合、ログイン後に元のページに戻るためのリダイレクトパスをクエリパラメータ（?redirect=/original/path）として保持することも検討します（将来的な拡張）。
   * リダイレクト後のログイン画面では、「セッションが期限切れになりました。再度ログインしてください」などの適切なメッセージを表示します。

## 3. トークン管理とセッションポリシー

### 3.1. トークン有効期限

実装されたトークン有効期限:

*   **アクセストークン（JWT）:** 15分（900秒）
*   **パスワードリセットトークン:** 1時間

### 3.2. JWT実装

JWTの処理は環境に応じて2つの実装を使用します:

*   **通常のAPI Routes:** `jsonwebtoken` ライブラリ
*   **Edge Runtime (Middleware):** `jose` ライブラリ

Edge Runtimeでは、Node.js固有のAPIが使用できないため、`jose`ライブラリを使用してJWTの検証を行います。

```javascript
// Edge Runtime用のJWT検証（jose使用）
import { jwtVerify, SignJWT, decodeJwt } from 'jose';

export async function verifyTokenEdge(token: string): Promise<JwtPayload | null> {
  try {
    const secretKey = new TextEncoder().encode(process.env.JWT_SECRET);
    const { payload } = await jwtVerify(token, secretKey);
    return {
      userId: payload.userId as string,
      email: payload.email as string,
      role: payload.role as string
    };
  } catch (error) {
    return null;
  }
}
```

### 3.3. ミドルウェアによる認証

Next.jsのミドルウェア（`src/middleware.ts`）で、APIルートへのアクセスを制御します:

```javascript
// 認証が必要なAPIパス
const AUTH_REQUIRED_PATHS = [
  '/api/projects',
  '/api/questions',
  '/api/answers',
  '/api/users',
  '/api/invitations',
  '/api/notifications',
  '/api/dashboard',
  '/api/answer-form-templates',
];

// 認証不要なAPIパス
const PUBLIC_PATHS = [
  '/api/auth/login',
  '/api/auth/register',
  '/api/auth/reset-password',
];
```

ミドルウェアは以下の処理を行います:
1. APIエンドポイントへのリクエストを検出
2. 認証不要なパスかチェック
3. `Authorization`ヘッダーからJWTトークンを取得
4. トークンを検証し、ユーザー情報をヘッダーに追加（`x-user-id`, `x-user-email`, `x-user-role`）
5. 認証失敗時は401エラーを返却

特殊な処理として、`/api/auth/me`エンドポイントは認証なしでもアクセス可能とし、トークンがない場合はnullを返します。

## 4. 認可（アクセス制御）

### 4.1. 役割（ロール）

*   **グローバルロール (`User.role`):**
    *   `ADMIN`: システム全体の管理者。全てのデータにアクセス可能。
    *   `USER`: 一般ユーザー。基本的な権限を持つ。
*   **プロジェクトロール (`ProjectMember.role`):**
    *   `MANAGER`: 特定プロジェクトの管理者。プロジェクト設定、メンバー管理、質問管理などを行う。
    *   `MEMBER`: 特定プロジェクトのメンバー。プロジェクト内の質問閲覧、回答などを行う。

### 4.2. アクセス制御の実装

*   **APIエンドポイントレベル:**
    *   バックエンドの各APIエンドポイントには、アクセスに必要なロール（グローバルロール、および/またはプロジェクトロール）を定義します。
    *   リクエスト受信時、バックエンドはJWTを検証し、ユーザーIDとグローバルロールを取得します。
    *   プロジェクト関連のエンドポイントでは、さらに `projectId` とユーザーIDを用いて `ProjectMember` テーブルを検索し、プロジェクトロールを確認します。
    *   定義されたロール要件を満たさない場合、`403 Forbidden` エラーを返します。
    *   API設計書 (`api_design.md`) に記載された各エンドポイントの `Authorization` 要件に従います。
*   **UIコンポーネントレベル:**
    *   フロントエンドは、ログインユーザーのロール情報（グローバルロール、および表示中のプロジェクトにおけるプロジェクトロール）を状態管理（Zustand）で保持します。
    *   このロール情報に基づき、特定のボタン（例: 「プロジェクト削除」「ユーザー招待」「質問編集」）やナビゲーションメニュー項目、設定画面セクションなどの表示/非表示、有効/無効を制御します。

### 4.3. 権限の詳細（再掲）

*   **ADMIN:** 全プロジェクト・全質問のCRUD、全ユーザー管理、システム設定。
*   **プロジェクト管理者 (MANAGER):** 担当プロジェクトの設定変更、タグ管理、メンバー招待・除外・役割変更、担当プロジェクト内の全質問のCRUD。
*   **通常ユーザー (USER / MEMBER):**
    *   自身が作成したプロジェクト/質問のCRUD（ただしプロジェクト削除はAdminのみ検討）。
    *   参加プロジェクト内の質問閲覧・回答。
    *   自身の回答の編集・削除。
    *   プロジェクト作成（作成者は自動的にMANAGERになる）。
    *   招待の承認/拒否。
    *   回答者として割り当てられた質問に対する回答義務（拒否権なし）。

## 5. セキュリティ対策

*   **パスワードハッシング:** bcryptjsを使用してパスワードをハッシュ化して保存します。
*   **JWTセキュリティ:**
    *   HTTPSを強制し、通信経路上でのトークン盗聴を防ぎます。
    *   JWT署名には環境変数で管理される秘密鍵を使用します。
    *   JWTペイロードには最小限の情報のみを含め、機密情報は含めません。
    *   JWTトークンの有効期限を15分と短く設定し、セキュリティリスクを軽減します。
*   **レート制限:** ログイン試行、パスワードリセット要求などにレート制限を設け、ブルートフォース攻撃を防ぎます。
    ```javascript
    // レート制限実装例（Next.js API Routeミドルウェア）
    import rateLimit from 'express-rate-limit';
    import slowDown from 'express-slow-down';
    
    const limiter = rateLimit({
      windowMs: 15 * 60 * 1000, // 15分
      max: 5, // 15分間に5回までのリクエスト
      message: { error: 'ログイン試行回数が多すぎます。しばらく経ってから再試行してください。' }
    });
    
    const speedLimiter = slowDown({
      windowMs: 15 * 60 * 1000, // 15分
      delayAfter: 3, // 3回目のリクエスト後に
      delayMs: 500 // 500msずつ遅延を増加
    });
    
    export default function middleware(req, res, next) {
      return speedLimiter(limiter(req, res, next));
    }
    ```
*   **CSRF対策:** リフレッシュトークンを取得するためにCross-Site Request Forgery (CSRF) トークンを使用します。
*   **入力検証:** フロントエンドとバックエンドの両方で厳格な入力検証を行い、インジェクション攻撃などを防ぎます。
*   **依存関係の管理:** 使用するライブラリ（認証ライブラリ、JWTライブラリなど）の脆弱性を定期的にチェックし、最新の状態に保ちます。

## 6. 技術選定

*   **パスワードハッシングライブラリ:** `bcryptjs`
*   **JWTライブラリ:** 
    *   `jsonwebtoken` (通常のAPI Routes用)
    *   `jose` (Edge Runtime/Middleware用)
*   **認証ミドルウェア:** Next.jsのミドルウェアでJWT検証とユーザー情報付与を行うカスタムロジック
*   **アクセストークン保存:** 状態管理（Zustand）
*   **認可管理:** RBACアプローチでロールベースの権限制御

